<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PLT</title>
    <script src="jspsych/jspsych.js"></script>
    <script src="jspsych/plugin-html-keyboard-response.js"></script>
    <script src="jspsych/plugin-instructions.js"></script>
    <script src="jspsych/plugin-call-function.js"></script>
    <script src="jspsych/plugin-preload.js"></script>
    <script src="plugin-PLT.js"></script>
    <script src="instructions.js"></script>
    <script src="utils.js"></script>
    <link href="jspsych/jspsych.css" rel="stylesheet" type="text/css" />
</head>
<style>
    .jsPsychDE {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: whitesmoke;
    }
</style>
<body>
    <div id='display_element' class='jsPsychDE'></div>
</body>
<script>
    code_version = 0.1

    // Conditions:
    // First digit - early stopping. 0 - no early stopping, 1 - early stopping
    // Second digit - valence grouped / interleaved. 0 - interleaved, 1 - grouped.
    // Third digit - reward first. 0 - punishment first, 1 - reward first, undefined - NA

    // Initialize jsPysch object
    let jsPsych = initJsPsych({
        display_element: 'display_element',
    });

    // Get condition from URL, all caps are prolific, lowercase are ours
    window.condition = jsPsych.data.getURLVariable('cond');
    window.prolificPID = jsPsych.data.getURLVariable('PROLIFIC_PID');
    window.studyId = jsPsych.data.getURLVariable('STUDY_ID');
    window.sessionId = jsPsych.data.getURLVariable('SESSION_ID');
    window.sessionNum = jsPsych.data.getURLVariable('session_num');

    // Parse condition
    window.earlyStop = window.condition[0] == "1"
    window.valenceGrouped = window.condition[1] == "1"
    window.rewardFirst = window.condition[2] == "1"

    // Save participant variables to data
    jsPsych.data.addProperties({
        prolific_pid: window.prolificPID,
        study_id: window.studyId,
        session_id: window.sessionId,
        session: window.sessionNum,
        condition: window.condition,
        early_stop: window.earlyStop,
        valence_grouped: window.valenceGrouped,
        reward_first: window.rewardFirst
    })

    window.skipThisBlock = false;
    window.accNumber = 0;
    
    inter_block_msg = {
        type: jsPsychHtmlKeyboardResponse,
        choices: ['s'],
        stimulus: function(){
            if (earlyStop & window.skipThisBlock){
                return "You've clearly identified the optimal card.<br><br>You will now see two new cards.<br><br>Press S key to continue.";
            }else{
                return "New round! You will see two new cards!";
            }
        },
        data: {
            trialphase: "break",
        },
        on_start: saveDataREDCap,
        on_finish: (data) => {
            data.earlybreak = window.skipThisBlock;
            window.skipThisBlock = false;
            window.accNumber = 0;
        }
    }

    inter_valence_msg = [
        {
            type: jsPsychHtmlKeyboardResponse,
            choices: ['space'],
            stimulus: function(){
                if ((window.rewardFirst & window.sessionNum == 1) | ((!window.rewardFirst) & window.sessionNum == 2)) {
                    return "<p>Well done.</p><p>You will now continue playing the Card Collector's Challenge, \
                        but this time to <b>avoid losing coins</b>. To start this part of the challenge, you recieve a purse with \
                        Â£x in coins. Every broken coin you discover will be deducted from your purse.</p>\
                        <p>Your goal is to lose as few coins as possible. Your bonus payment will be based on the number of \
                            coins you have left at the end of the challenge.</p>\
                            <p>Press the space bar to continue.</p>"
                } else {
                    return "<p>Well done.</p><p>You will now continue playing the Card Collector's Challenge, \
                        but this time to <b>win coins</b>.</p>\
                        <p>Your goal is to win as many coins as possible. Your bonus payment will be based on the number of \
                            coins you have at the end of the challenge.</p>\
                            <p>Press the space bar to continue.</p>"
                }
            },
            data: {
                trialphase: "change_valence",
            },
            on_start: saveDataREDCap,
            on_finish: (data) => {
                data.earlybreak = window.skipThisBlock;
                window.skipThisBlock = false;
                window.accNumber = 0;
            }
        },
        {
            type: jsPsychHtmlKeyboardResponse,
            choice: ['f', 'j'],
            stimulus: "<p>Place your fingers on the keyboard as shown below, and press either the 'F' or 'J' key to start playing again.</p>",
            data: {
                trialphase: "change_valence"
            }
        }
    ]

    PLT_trial =  {
        timeline: [{
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div style="font-size:60px">+</div>',
            choices: "NO_KEYS",
            trial_duration: 800,
            data: {trialphase: "fixation"},
        },
        {
            type: jsPsychPLT,
            imgLeft: () => 'imgs/'+ jsPsych.timelineVariable('stimulus_left'),
            imgRight: () => 'imgs/'+ jsPsych.timelineVariable('stimulus_right'),
            outcomeLeft: jsPsych.timelineVariable('feedback_left'),
            outcomeRight: jsPsych.timelineVariable('feedback_right'),
            optimalRight: jsPsych.timelineVariable('optimal_right'),
            data: {
                trialphase: "task",
                block: jsPsych.timelineVariable('block'),
                trial: jsPsych.timelineVariable('trial'),
                valence: jsPsych.timelineVariable('valence')
            },
            on_finish: function(data) {
                if (data.isOptimal) {
                    window.accNumber++;
                } else {
                    window.accNumber = 0;
                }
                if (window.accNumber === 5){
                    if (earlyStop){
                        window.skipThisBlock = true
                    }
                }
                console.log(window.accNumber)
            }
        }
        ],
        conditional_function: function(){
            return !window.skipThisBlock
        }
    } 
    
    function build_PLT_task(structure){
        let PLT_task = [];
        for (let i=0; i < window.totalBlockNumber; i++){
            block = [
                {
                    timeline: [PLT_trial],
                    timeline_variables: structure[i]
                }
            ];
            
            // Add message
            if (window.valenceGrouped & (i == (totalBlockNumber / 2 - 1))) {
                block.push(inter_valence_msg);
            } else {
                block.push(inter_block_msg);
            }
            
            PLT_task = PLT_task.concat(block)
        }

        return PLT_task
    }

    function run_full_experiment(structure){
        
        // Add instructions
        // procedure = prepare_instructions();

        // Add PLT
        procedure = procedure.concat(build_PLT_task(structure));

        // Final messages and data saving
        procedure.push({                
            type: jsPsychHtmlKeyboardResponse,
            stimulus: "Well done! You have finished the experiment.",
            data: {trialphase: "end"},
            on_start: saveDataREDCap
        })

        // Run
        jsPsych.run(procedure);
    }

    // Load sequences and start
    var procedure = [];

    async function load_squences(condition, session) {
        try {
            const response = await fetch('PLT_task_structure_' + condition + '.json');
            
            if (!response.ok) {
            throw new Error('Network response was not ok');
            }
            const structure = await response.json();
            const sess_structure = structure[session - 1];

            window.totalBlockNumber = sess_structure.length

            // Fetch the current time from the World Time API
            const time_resp = await fetch('http://worldtimeapi.org/api/timezone/Europe/London');

            if (!time_resp.ok) {
            throw new Error('Network response was not ok');
            }

            const date_data = await time_resp.json();

            const verifiedDateString = date_data.datetime;

            window.startTime = format_date_from_string(verifiedDateString)

            run_full_experiment(sess_structure);
        } catch (error) {
            console.error('There was a problem with the fetch operation:', error);
        }
    }

    load_squences(window.condition, window.sessionNum);
        
</script>
</html>